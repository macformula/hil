{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"McMaster Formula Electric","text":"<p>Software-in-the-loop documentation page</p>"},{"location":"#tutorials","title":"Tutorials","text":""},{"location":"#mac-formula","title":"Mac Formula","text":""},{"location":"macfe/","title":"SIL for McMaster FE","text":"<p>This section explains how McMaster Formula Electric uses the SIL.</p>"},{"location":"macfe/run/","title":"Running the SIL","text":"<p>The <code>cmd/hilapp/main.go</code> file is the entry point to our SIL application. Compiling and running this binary will start the SIL cli.</p> <p>To compile the hilapp binary, navigate to the <code>cmd/hilapp</code> directory, and run <code>go build</code></p>"},{"location":"macfe/run/#more-coming-soon","title":"MORE COMING SOON","text":""},{"location":"macfe/setup/","title":"Developer Setup","text":"<p>Follow these steps to begin developing in <code>racecar/hil</code>.</p>"},{"location":"macfe/setup/#dependencies","title":"Dependencies","text":""},{"location":"macfe/setup/#go","title":"Go","text":"<p>In order to compile and run Go code, you must download Go.</p> <p>Go to Go documentation page and follow the installation guide.</p> <p>To verify Go is installed correctly, run:</p> <pre><code>go version\n</code></pre>"},{"location":"macfe/setup/#grpc","title":"gRPC","text":"<p>You will need a Unix development environment (Unix machine, WSL, or remote into the Raspberry Pi).</p> <p>Go through the gRPC Go Quickstart Guide. Build the example project.</p> <p>As long as you can successfully build the gRPC example and have Go installed you are ready to get started with the SIL!</p>"},{"location":"macfe/setup/#precommit-setup","title":"Precommit setup","text":"<p>We have a precommit that will ensure <code>go fmt</code> is ran before every commit to maintain style consistency. To </p> WindowsMac/Linux <ol> <li>If you don't already have Python installed, get it from https://www.python.org/downloads.</li> <li>Open a terminal and run: <pre><code>pip install pre-commit\n</code></pre></li> <li>Open a terminal in the <code>hil</code> directory and run: <pre><code>pre-commit install\n</code></pre></li> </ol> <ol> <li>If you don't already have Python installed, get it from https://www.python.org/downloads, or by using a package manager like Brew.</li> <li>Open a terminal and run: <pre><code>pip3 install pre-commit\n</code></pre></li> <li>Open a terminal in the <code>hil</code> directory and run: <pre><code>pre-commit install\n</code></pre></li> </ol> <p>Now if you try committing to your local repository with formatting errors in a <code>.go</code> file, an error will be thrown and your code will automatically be reformated!</p>"},{"location":"tutorials/","title":"Index","text":"<p> 1. Creating the Main Application 2. Defining I/O 3. Creating ECU Objects 4. Creating the <code>main</code> application </p>"},{"location":"tutorials/setup/1/","title":"The SIL Application","text":""},{"location":"tutorials/setup/1/#introduction","title":"Introduction","text":"<p>The <code>macfe/hil</code> package is a software-in-the-loop testing package developed in Go. This tutorial will walkthrough the process of using this package to test firmware application. This walkthrough assumes you are working in a Linux environment. We will build a suite of SIL tests for the following firmware code:</p> <pre><code>int main(void) {\n    bindings::Initialize();\n\n    while (1) {\n        btn_value = bindings::button_di.Read();\n        bindings::indicator_do.Set(btn_value);\n    }\n\n    return 0;\n}\n</code></pre> <p>In <code>main</code>, we read in a digital input from a button then set an indicator led to match the input. Although this is simple example, it will demonstrate how to leverage the <code>macfe/hil</code> package to validate firmware code.</p>"},{"location":"tutorials/setup/1/#dependencies","title":"Dependencies","text":"<p>TODO</p>"},{"location":"tutorials/setup/1/#file-structure","title":"File structure","text":"<p>To start, create an empty directory to hold all of your SIL related files. We will call it <code>sil</code>. Set up the <code>sil</code> directory to have this file structure. </p> <pre><code>sil\n\u251c\u2500\u00a0config\n\u251c\u2500\u00a0cmd\n\u251c\u2500\u00a0ecu\n\u251c\u2500\u00a0pinout\n\u251c\u2500\u00a0state\n\u2514\u2500\u00a0results\n    \u2514\u2500\u00a0logs\n</code></pre> <p>Open a terminal in the <code>sil</code> directory and run this command, replacing the argument with a path to your git repository:</p>"},{"location":"tutorials/setup/1/#initializing-our-module","title":"Initializing our module","text":"<pre><code>go mod init github.com/example/repo\n</code></pre> <p>This will mark our directory as a Go module and create a <code>go.mod</code> file to track our dependencies. Let's create our module's <code>main</code> function inside the <code>sil/cmd</code> directory. </p> <pre><code>package main\n\nfunc main() {\n\n}\n</code></pre> <p>This <code>main</code> function will be the entry point to our entire SIL application.</p>"},{"location":"tutorials/setup/2/","title":"Defining I/O","text":"<p>In order for our firmware code to manipulate I/O pins we can use a <code>Controller</code> struct defined in the <code>macfe/hil/iocontrol/sil</code> package. The <code>Controller</code> stores an internal representation of all input and output pins needed to run a test, both digital and analog. This model can then be queried using gRPC requests to the SIL server. In our case, when our firmware executes <code>btn_value = bindings::button_di.Read();</code>, it will really just send a request to our <code>Controller</code> to check the value of the button pin. The <code>Controller</code> will then check its internal model, and send a gRPC response back with the current value of the pin.</p>"},{"location":"tutorials/setup/2/#listing-io-pins","title":"Listing I/O pins","text":"<p>Inside the <code>sil/pinout</code> directory, we will establish the physical input and output pins our ECU's require. </p> <pre><code>package pinout\n\n//go:generate enumer -type=PhysicalIo \"physicalio.go\"\n\n// PhysicalIo represents an input/output in its physical meaning.\ntype PhysicalIo int\n\nconst (\n    UnknownPhysicalIo PhysicalIo = iota\n\n    IndicatorButton\n    IndicatorLed\n)\n</code></pre>"},{"location":"tutorials/setup/2/#creating-a-revision","title":"Creating a <code>Revision</code>","text":"<p>Next, create a file in <code>hil/pinout</code> called <code>revision.go</code>, to list all revisions.</p> <pre><code>package pinout\n\n//go:generate enumer -type=Revision \"revision.go\"\ntype Revision int\n\nconst (\n    Sil Revision = iota\n)\n</code></pre> <p>Each <code>Revision</code> will be associated with a collection of I/O pins. When we construct a <code>Controller</code> struct, we will pass in a selected <code>Revision</code>, indicating to the <code>Controller</code> what pins need to be registered for its model. Our simple example only has one revision, but for more complex projects, more revisions will likely be needed. </p> <p>Then, create a specific revision for SIL inside a new file called <code>hil/pinout/pinout.go</code>.</p> <pre><code>package pinout\n\nimport (\n    \"github.com/macformula/hil/iocontrol\"\n    \"github.com/macformula/hil/iocontrol/sil\"\n    \"github.com/pkg/errors\"\n)\n\n// DigitalPinout maps physical IO to digital pins.\ntype DigitalPinout map[PhysicalIo]iocontrol.DigitalPin\n\n// AnalogPinout maps physical IO to analog pins.\ntype AnalogPinout map[PhysicalIo]iocontrol.AnalogPin\n\nvar _revisionDigitalInputPinout = map[Revision]DigitalPinout{\n    Sil: {\n        IndicatorLed:               sil.NewDigitalInputPin(\"DemoProject\", IndicatorLed.String()),\n    },\n}\n\nvar _revisionDigitalOutputPinout = map[Revision]DigitalPinout{\n    Sil: {\n        IndicatorButton:  sil.NewDigitalOutputPin(\"DemoProject\", IndicatorButton.String()),\n    },\n}\n</code></pre> <p>SIL Input/Output</p> <p><code>Revision</code>'s define I/O from the \"SIL perspective\". The indicator led for example is an output to the firmware, but an input to the SIL. </p>"},{"location":"tutorials/setup/3/","title":"ECU Objects","text":"<p>Ultimately, an ECU receives I/O from physical pins (represented by <code>pinout.Controller</code>) and CAN frames  (represented by <code>canlink.BusManager</code>) control the I/O for a given ECU. In order to make testing an ECU easy,  we will wrap these structs in a <code>Client</code> object for easier testing. Each test state will use this  ECU object to simulate an I/O to ensure it responds accordingly. Although our example firmware is designed to run on  a single board, bundling I/O by ECU's makes testing for interactions across ECU's much easier. </p>"},{"location":"tutorials/setup/3/#client-struct","title":"Client struct","text":"<p>Inside the <code>sil/ecu</code> folder create a folder called <code>DemoController</code>, with a file in this folder called <code>client.go</code>. Mark this file as a Go module called <code>DemoController</code>, with a <code>Client</code> struct. </p> <pre><code>package democontroller\n\nimport (\n    \"go.uber.org/zap\"\n\n    \"github.com/macformula/hil/canlink\"\n    \"github.com/sil/pinout\"\n    \"github.com/pkg/errors\"\n)\n\nconst (\n    _clientName = \"demo_controller_client\"\n)\n\ntype Client struct {\n    l             *zap.Logger\n    pinController *pinout.Controller\n}\n\n// NewClient creates a new demo controller client.\nfunc NewClient(pinController *pinout.Controller, l *zap.Logger) *Client {\n    return &amp;Client{\n        l:             l.Named(_clientName),\n        pinController: pinController,\n    }\n}\n</code></pre> <p>Note</p> <p>A <code>Client</code> may also have a <code>BusManager</code> property if it needs to send/receive CAN frames.</p> <p>Our firmware code preforms I/O in only two ways: it reads a digital input from a button, and sets a digital output to a led. Let's start by adding a method to read the signal of the <code>IndicatorLed</code>.</p> <p><pre><code>func (c *Client) ReadIndicatorLed() (bool, error) {\n    lvl, err := c.pinController.ReadDigitalLevel(pinout.IndicatorLed)\n    if err != nil {\n        return false, errors.Wrap(err, \"read digital level (indicator led)\")\n    }\n\n    return lvl, nil\n}\n</code></pre> This method queries the <code>Client.pinController</code> for the <code>IndicatorLed</code>, then ensures the operation was successful.  A similar function can be implemented to set the <code>indicatorButton</code>.</p> <pre><code>func (c *Client) SetIndicatorButton(value bool) error {\n    err := c.pinController.SetDigitalLevel(pinout.IndicatorButton, value)\n    if err != nil {\n        return errors.Wrap(err, \"set digital level (indicator button)\")\n    }\n\n    return nil\n}\n</code></pre> <p>This <code>Client</code> struct is now complete and test states can use it to preform I/O operations on the <code>demoController</code>. </p>"},{"location":"tutorials/setup/4/","title":"SIL App","text":"<p>A SIL application contains a variety of high level structs that persist for the duration of a SIL test.  Some of these structs need to access the properties and methods of other structs during a test. To make this interfacing easier, let's create a SIL struct to bundle our main application.</p>"},{"location":"tutorials/setup/4/#sil-package","title":"SIL package","text":"<p>Create a file in the <code>sil</code> called <code>app.go</code>.</p> <pre><code>package demoSil\n\nimport (\n    \"github.com/macformula/hil/canlink\"\n    \"github.com/sil/ecu/democontroller\"\n    \"github.com/sil/pinout\"\n)\n\n// App represents the main application, it persists across multiple sequence runs.\ntype App struct {\n    PinoutController      *pinout.Controller\n    DemoControllerClient  *demoController.Client\n\n    CurrProcess           *ProcessInfo\n}\n</code></pre> <p>When we eventually implement <code>State</code>'s they will use this app struct to access the <code>Client</code> and <code>Controller</code> for the current test.</p>"},{"location":"tutorials/setup/5/","title":"Test States","text":"<p><code>macfe/hil</code> organizes testing logic using <code>Sequence</code>'s, <code>State</code>'s and <code>Tag</code>'s. A <code>Sequence</code>  is a high level struct that contains an array of <code>State</code>'s that are run in the order provided.  During a <code>State</code>, our SIL will alter certain inputs to firmware,  then verify the response is correct by checking output pins. A <code>State</code> may  also send messages across the virtual CAN bus, and ensure firmware responds  accordingly. The results from a SIL test are organized by <code>Tag</code>'s. These contain a high level  description of simple properties that can be validated by a <code>State</code>.</p>"},{"location":"tutorials/setup/5/#state","title":"State","text":"<p>Let's create a new state called <code>demoState</code> inside the <code>sil/state/demo.go</code> folder.</p> <pre><code>package state\n\nimport (\n    \"context\"\n    \"errors\"\n    \"time\"\n\n    \"github.com/macformula/hil/flow\"\n)\n\nconst (\n    _name = \"demo_test_state\"\n)\n\ntype demoState struct {\n    l  *zap.Logger\n    a  *macformula.App\n    dc *democontroller.Client\n\n    fatalErr utils.ResettableError\n\n    results map[flow.Tag]any\n}\n\nfunc newDemoState(l *zap.logger, a *macformula.App) *demoState {\n    return &amp;demoState{\n        l: l,\n        a: a,\n        dc: a.DemoControllerClient,\n\n        results: map[flow.Tag]any{},\n    }\n}\n\nfunc (d *demoState) GetResults() map[flow.Tag]any {\n    return d.results\n}\n\nfunc (d *demoState) ContinueOnFail() bool {\n    return true\n}\n\n// Timeout returns the state setup and run timeout.\nfunc (d *demoState) Timeout() time.Duration {\n    return time.Minute\n}\n\n// Setup executes any necessary setup logic before run.\nfunc (d *demoState) Setup(ctx context.Context) error {\n    n.setupCalled = true\n\n    return nil\n}\n\n// Name is the name of the state.\nfunc (d *demoState) Name() string {\n    return _name\n}\n\n// Run is the logic that gets executed after setup.\nfunc (d *demoState) Run(_ context.Context) error {\n    return nil\n}\n\n// FatalError indicates if any non-recoverable errors have occured.\nfunc (d *demoState) FatalError() error {\n    return d.fatalErr\n}\n</code></pre> <p>Info</p> <p>Even though some of these methods will not be used for every <code>State</code>, they must be defined in order for <code>demoState</code> to implement the <code>State</code> interface.</p>"},{"location":"tutorials/setup/5/#state-logic","title":"State logic","text":"<p>Now that our initial <code>demoState</code> is defined, we can add testing logic inside the <code>Run</code> method.  For our example, there are two main conditions we want to test. When the firmware receives a high signal from the button input, it should output a high signal. When it receives a low signal it should output a low signal. The <code>State</code> will act as this button through the <code>DemoControllerClient</code>, then verify the output pins are set to the correct signal.</p>"}]}