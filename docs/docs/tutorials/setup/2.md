# Defining I/O

In order for our firmware code to manipulate I/O pins we can use a `Controller` struct defined in the `macfe/hil/iocontrol/sil` package. The `Controller` stores an internal representation of all input and output pins needed to run a test, both digital and analog. This model can then be queried using gRPC requests to the SIL server. In our case, when our firmware executes `btn_value = bindings::button_di.Read();`, it will really just send a request to our `Controller` to check the value of the button pin. The `Controller` will then check its internal model, and send a gRPC response back with the current value of the pin.

## Listing I/O pins

Inside the `sil/pinout` directory, we will establish the physical input and output pins our ECU's require. 

```go
package pinout

//go:generate enumer -type=PhysicalIo "physicalio.go"

// PhysicalIo represents an input/output in its physical meaning.
type PhysicalIo int

const (
	UnknownPhysicalIo PhysicalIo = iota

	IndicatorButton
	IndicatorLed
)
```

## Creating a `Revision`

Next, create a file in `hil/pinout` called `revision.go`, to list all revisions.

```go
package pinout

//go:generate enumer -type=Revision "revision.go"
type Revision int

const (
	Sil Revision = iota
)
```

Each `Revision` will be associated with a collection of I/O pins. When we construct a `Controller` struct, we will pass in a selected `Revision`, indicating to the `Controller` what pins need to be registered for its model.
Our simple example only has one revision, but for more complex projects, more revisions will likely be needed. 

Then, create a specific revision for SIL inside a new file called `hil/pinout/pinout.go`.

```go
package pinout

import (
	"github.com/macformula/hil/iocontrol"
	"github.com/macformula/hil/iocontrol/sil"
	"github.com/pkg/errors"
)

// DigitalPinout maps physical IO to digital pins.
type DigitalPinout map[PhysicalIo]iocontrol.DigitalPin

// AnalogPinout maps physical IO to analog pins.
type AnalogPinout map[PhysicalIo]iocontrol.AnalogPin

var _revisionDigitalInputPinout = map[Revision]DigitalPinout{
	Sil: {
		IndicatorLed:               sil.NewDigitalInputPin("DemoProject", IndicatorLed.String()),
	},
}

var _revisionDigitalOutputPinout = map[Revision]DigitalPinout{
	Sil: {
		IndicatorButton:  sil.NewDigitalOutputPin("DemoProject", IndicatorButton.String()),
	},
}
```

!!! info "SIL Input/Output"

	`Revision`'s define I/O from the "SIL perspective". The indicator led for example is an output to the firmware, but an input to the SIL. 

