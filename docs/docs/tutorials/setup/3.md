# ECU Objects

Ultimately, an ECU receives I/O from physical pins (represented by `pinout.Controller`) and CAN frames 
(represented by `canlink.BusManager`) control the I/O for a given ECU. In order to make testing an ECU easy, 
we will wrap these structs in a `Client` object for easier testing. Each test state will use this 
ECU object to simulate an I/O to ensure it responds accordingly. Although our example firmware is designed to run on 
a single board, bundling I/O by ECU's makes testing for interactions across ECU's much easier. 

## Client struct

Inside the `sil/ecu` folder create a folder called `DemoController`, with a file in this folder called `client.go`.
Mark this file as a Go module called `DemoController`, with a `Client` struct. 

```go
package democontroller

import (
	"go.uber.org/zap"

	"github.com/macformula/hil/canlink"
	"github.com/sil/pinout"
	"github.com/pkg/errors"
)

const (
	_clientName = "demo_controller_client"
)

type Client struct {
	l             *zap.Logger
	pinController *pinout.Controller
}

// NewClient creates a new demo controller client.
func NewClient(pinController *pinout.Controller, l *zap.Logger) *Client {
	return &Client{
		l:             l.Named(_clientName),
		pinController: pinController,
	}
}
```

!!! note Client properties

	A `Client` may also have a `BusManager` property if it needs to send/receive CAN frames.

Our firmware code preforms I/O in only two ways: it reads a digital input from a button, and sets a digital output to a led.
Let's start by adding a method to read the signal of the `IndicatorLed`.

```go
func (c *Client) ReadIndicatorLed() (bool, error) {
	lvl, err := c.pinController.ReadDigitalLevel(pinout.IndicatorLed)
	if err != nil {
		return false, errors.Wrap(err, "read digital level (indicator led)")
	}

	return lvl, nil
}
```
This method queries the `Client.pinController` for the `IndicatorLed`, then ensures the operation was successful. 
A similar function can be implemented to set the `indicatorButton`.

```go
func (c *Client) SetIndicatorButton(value bool) error {
	err := c.pinController.SetDigitalLevel(pinout.IndicatorButton, value)
	if err != nil {
		return errors.Wrap(err, "set digital level (indicator button)")
	}

	return nil
}
```

This `Client` struct is now complete and test states can use it to preform I/O operations on the `demoController`. 